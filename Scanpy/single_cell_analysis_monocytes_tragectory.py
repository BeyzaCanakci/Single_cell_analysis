# -*- coding: utf-8 -*-
"""Single-Cell-Analysis-Monocytes-Trajectory.ipynb

Automatically generated by Colab.

Original file is located at
    single_cell_analysis_monocytes_trajectory.ipynb
"""

pip install scanpy

import scanpy as sc
import matplotlib.pyplot as plt
adata = sc.datasets.pbmc3k()

"""DATASET: It is a Peripheral Blood Mononuclear Cells (PBMC) scRNA-seq data of around 2700 cells.

One-dimensional: Contains only gene expression (RNA counts).
"""

adata
adata.obs.head()

adata.var.head()

adata.var["mt"] = adata.var_names.str.startswith("MT-")
print("Mitochondria genes have been marked:")
print(adata.var["mt"].value_counts())  # How many mitochondria genes present?

sc.pp.calculate_qc_metrics(adata, qc_vars=["mt"], percent_top=None, log1p=False, inplace=True)
adata.obs.head()

import seaborn as sns
import matplotlib.pyplot as plt

# Total RNA
sns.histplot(adata.obs["total_counts"], bins=50)
plt.title("Total RNA per cell (total_counts)")
plt.show()

# The number of genes
sns.histplot(adata.obs["n_genes_by_counts"], bins=50)
plt.title("Number of genes per cell (n_genes_by_counts)")
plt.show()

# Mitochondria ratio
sns.histplot(adata.obs["pct_counts_mt"], bins=50)
plt.title("Mitochondria ratio (%)")
plt.show()

print("Number of cell before filtering:", adata.n_obs)

adata = adata[adata.obs.n_genes_by_counts < 2500, :]
adata = adata[adata.obs.pct_counts_mt < 5, :]
print("Number of cell after filtering:", adata.n_obs)

sc.pp.normalize_total(adata, target_sum=1e4)

print("Normalization done.")
print(" Total RNA in sample cell (all must be ~10.000):")
print(adata.obs["total_counts"].head())

sc.pp.log1p(adata)

print("Log1p transformation.")

print("ex. expression of 'IL7R' gene in first 5 cell:")
print(adata[:, "IL7R"].X[:5])

sc.pp.highly_variable_genes(
    adata,
    min_mean=0.0125,
    max_mean=3,
    min_disp=0.5
)

print("Highly variable genes")
print("How many total Highly variable genes have been selected?")
print(adata.var.highly_variable.sum())

print(" The first 10 highly variable gene as an example:")
print(adata.var[adata.var.highly_variable].head(10).index.tolist())

sc.pl.highly_variable_genes(adata)

import numpy as np
import matplotlib.pyplot as plt

hvgs = adata.var["highly_variable"].values  # numpy array
colors = np.where(hvgs, "orange", "gray")   # True → orange, False → gray

plt.figure(figsize=(8, 6))
plt.scatter(adata.var["means"], adata.var["dispersions"],
            c=colors, s=5)
plt.xlabel("Mean expression")
plt.ylabel("Dispersion")
plt.title("Highly variable genes")
plt.show()

hvgs = adata.var["highly_variable"]
print("True  (selected genes):", hvgs.sum())
print("False  (not selected genes):", (~hvgs).sum())

adata = adata[:, adata.var.highly_variable]
print("Dataset contain only highly variable genes. New dimension:")
print(adata.shape)

sc.pp.scale(adata, max_value=10)

print(" Dataset scaled.")

sc.tl.pca(adata, svd_solver='arpack')

print("PCA done. The first 5 components :")
print(adata.obsm["X_pca"][:5])  # PCA result of each cell

sc.pp.neighbors(adata, n_neighbors=10, n_pcs=40)

print(" Neighbors matrix oluşturuldu.")
#n_neighbors=10: look at 10 nearest cells for each cell.

#n_pcs=40: Use the first 40 component in PCA because they carry the most variance

sc.tl.umap(adata)

print("UMAP coordination calculated")
print("UMAP for the first 5 cell")
print(adata.obsm["X_umap"][:5])

pip install leidenalg

sc.tl.leiden(adata, resolution=0.5)

print("Leiden clustering")
print("Labels of the first 10 cell")
print(adata.obs["leiden"].head(10))

"""resolution=0.5 → affect the cluster number:

less resolution → less cluster

high resoltion → high cluster
"""

sc.pl.umap(adata, color='leiden')

"""Each dots represent the one cell

Colors: represent the Leiden cluster

Those of the same color can be from the same cell subtype.
"""

sc.tl.rank_genes_groups(adata, groupby='leiden', method='t-test')

print("Marker genes calculated.")

sc.pl.rank_genes_groups(adata, n_genes=20, sharey=False)

"""Shows the most meaningful different expression of 20 gene for each cluster

X axis: cluster (leiden 0, 1, 2…)

Y axis: ordered gene by log fold-change or p-value
"""

result = adata.uns['rank_genes_groups']
groups = result['names'].dtype.names

print("The first 3 marker genes for each cluster:")
for group in groups:
    print(f"Cluster {group}: {result['names'][group][:3]}")

import pandas as pd

marker_df = pd.DataFrame({
    group + '_' + key: result[key][group]
    for group in result['names'].dtype.names
    for key in ['names', 'pvals', 'logfoldchanges']
})

marker_df.to_csv("marker_genler_pbmc3k.csv")
print("Marker genes were saved to csv.")

cluster_names = {
    '0': 'Naive/Memory T cells',
    '1': 'Monocytes',
    '2': 'NK cells',
    '3': 'B cells',
    '4': 'Dendritic cells',
    '5': 'Megakaryocytes'
}

adata.obs['cell_type'] = adata.obs['leiden'].map(cluster_names)

print(" New labelles were added. First 10 cell:")
print(adata.obs[['leiden', 'cell_type']].head(10))

sc.pl.umap(adata, color='cell_type', legend_loc='on data')

sc.pl.umap(adata, color=['CD2'])

genes_of_interest = [
    'MS4A1',    # B cells
    'CD79A',    # B cells
    'NKG7',     # NK cells
    'GNLY',     # NK cells
    'LTB',      # T Cell
    'PF4',     # Megakaryocytes
    'PPBP',     # Megakaryocytes
    'FCER1A'    # DCs
]

sc.pl.dotplot(adata, genes_of_interest, groupby='cell_type', dendrogram=True)

"""Color shade: average gene expression

Size of the dot: how many cell are expressed this gene  

Dendrogram: cell types are grouped by automatically
"""

sc.tl.paga(adata, groups='cell_type')
sc.pl.paga(adata, threshold=0.1, show=True)

"""In this step, we will model how cells progress through a developmental process (trajectory).
Scanpy does this using PAGA and DPT (Diffusion Pseudotime).
The above graph shows the transition probabilities between cell types.
"""

sc.tl.umap(adata, init_pos='paga')
sc.pl.umap(adata, color='cell_type', legend_loc='on data')
#Paga graph gives UMAP more accurately → The transition direction of cells looks more meaningful.

"""#Check out the Pseudotime
DPT does not work without this step. Unlike PCA, it is suitable for modeling cell transitions.

"""

sc.tl.diffmap(adata)

"""This is the cell in which the cellular journey begins. It usually becomes a progenitor or naive t cell.


"""

# Took a cell from 'Naive/Memory T cells' cluster
root_cell = adata.obs[adata.obs['cell_type'] == 'Naive/Memory T cells'].index[0]

adata.uns['iroot'] = adata.obs_names.get_loc(root_cell)
sc.tl.dpt(adata)

"""adata.uns ['iroot']: gives the "starting point" to the DPT algorithm.

get_loc () → gives the sequence of the cell (eg 154. Cell)


"""

sc.pl.umap(adata, color='dpt_pseudotime')
#This graph shows the positions of the cells in the development process on 0 → 1 scale
#Light color → Early stage, dark color → late stage

sc.pl.umap(adata, color=['cell_type', 'dpt_pseudotime'], cmap='viridis')
#You can see both cell types and pseudotime flow at the same time.

"""#Pseudotime Heatmap (Expression, etc. temporal flow)

Let's see how gene expressions change along pseudotime with Heatmap
"""

import pandas as pd
from scipy.stats import spearmanr
import numpy as np

# Spearman correlation for each cell
gene_corr = []
for gene in adata.var_names:
    try:
        r, _ = spearmanr(adata[:, gene].X.toarray().flatten(), adata.obs['dpt_pseudotime'])
        gene_corr.append((gene, r))
    except:
        pass

# Take the 50 genes of highest correlation
top_genes = sorted(gene_corr, key=lambda x: abs(x[1]), reverse=True)[:50]
top_gene_names = [g[0] for g in top_genes]

sc.pl.heatmap(
    adata,
    var_names=top_gene_names,
    groupby='cell_type',
    use_raw=False,
    swap_axes=True,
    show=True
)

"""#Trajectory- PAGA & pseudotime"""

sc.pl.umap(adata, color='dpt_pseudotime', edges=True, edges_width=1, edges_color='gray')

"""Trajectory is now visible

#Pathway Enrichment (Gene Set Analysis)

Now let's find out which biological ways are activated with genes that change along pseudotime.
For this, we will perform an outward transfer + Gsea analysis.
"""

# Most Increasing Genes According to Correlation
df = pd.DataFrame(top_genes, columns=["gene", "correlation"])
df.to_csv("pseudotime_genes_ranked.csv", index=False)
print("Genes list are saved")

"""You can use this file in a tool like Gsea (G: Profiler, Enrichr, Webgestalt, David ...).

#Alternative: Pathway Enrichment through Python (Gseapy)
---
"""

pip install gseapy

import gseapy as gp

genes = [g[0] for g in top_genes if g[1] > 0]  # only positive correlation
enr = gp.enrichr(gene_list=genes,
                 gene_sets='KEGG_2021_Human',
                 outdir='gsea_results',
                 cutoff=0.05)

enr.results.head()

"""Analysis above:

Which roads are active → eg. "T Cell Recedor Signaling"

Which biological functions are changing → “Apoptosis”, “Cytokine Signaling”

#Cell Type Specific Trajectory (Development Way)
"""

# Select the 'Monocytes' in cell type column
mono = adata[adata.obs['cell_type'] == 'Monocytes'].copy()

print(" The number Monocyte cell:", mono.shape[0])

"""Repeat the preparation for Trajectory (Monocytes only)"""

# PCA
sc.pp.pca(mono)
sc.pp.neighbors(mono)
sc.tl.diffmap(mono)

# Select the Root cell (If desired, as the first cell)
root_cell = mono.obs_names[0]
mono.uns['iroot'] = mono.obs_names.get_loc(root_cell)

# Pseudotime
sc.tl.dpt(mono)

""" Pseudotime UMAP and Heatmap

"""

# Pseudotime UMAP ve Heatmap

# init_pos = we use 'PCA' instead of 'paga' because Mono contains only one cell type
sc.tl.umap(mono, init_pos='pca')
sc.pl.umap(mono, color='dpt_pseudotime', cmap='viridis')

"""#Find genes that vary according to Pseudotime"""

# Sorted by correlation
from scipy.stats import spearmanr
gene_corr = []
for gene in mono.var_names:
    try:
        r, _ = spearmanr(mono[:, gene].X.toarray().flatten(), mono.obs['dpt_pseudotime'])
        gene_corr.append((gene, r))
    except:
        continue

top_genes = sorted(gene_corr, key=lambda x: abs(x[1]), reverse=True)[:50]
top_gene_names = [g[0] for g in top_genes]

# Remove sort_order=True which caused the AttributeError
sc.pl.heatmap(mono, var_names=top_gene_names, use_raw=False, swap_axes=True, groupby='cell_type')

"""# Optional: Pathway Analysis (Monocytes only)
---



In the same way, we can take these top genes with the above Gseapy and can only analyze KEG or GO Pathway for this type of cell type.
"""

from gseapy import enrichr

genes = [g[0] for g in top_genes if g[1] > 0]
enr = enrichr(gene_list=genes,
              gene_sets='GO_Biological_Process_2021',
              organism='Human',
              outdir='mono_pathways',
              cutoff=0.05)

enr.results.head(10)
